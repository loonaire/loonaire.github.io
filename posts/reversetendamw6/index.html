<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Reverse Tenda MW6 for fun - Loonaire Blog</title><meta name=description content="
Cet article n&rsquo;est pas terminé, il ne s&rsquo;agit que du début, la suite arrivera plus tard
Ca fait un moment que je souhaitais m&rsquo;initier sérieusement au reverse d&rsquo;un appareil chinois, l&rsquo;objectif est de comprendre ses fonctionnements, vérifier ce qui est remonté aux serveur et aller le plus loin possible pour ce qu&rsquo;on peux faire avec.
La cible
La cible sera une borne Wifi Tenda MW6, le lien officiel du fabricant est disponible ici: https://web.archive.org/web/20220707094929/https://www.tendacn.com/fr/product/specification/mw6.html"><meta name=author content><link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><script src=https://unpkg.com/themes.js></script><script>window.themes=window.themes||new window.Themes</script><style>:root{--font-sans:"Inter var", ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, Noto Sans, sans-serif, Apple Color Emoji, Segoe UI Emoji, Segoe UI Symbol, Noto Color Emoji}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000"><div class="h:full
w:full
max-w:1200
mx:auto
px:32
d:flex
align-items:center"><div><a href=../../ class="mr-3 font:extralight">Loonaire Blog</a></div><div class=ml:auto><a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../posts/ title>Articles</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../other/ title>Autre contenu</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../about title>A propos</a></div></div></nav><div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:700 w:full box:content-box"><article class="box:border-box pt:32"><header class=mb:32><div class="font:40 font:extrabold">Reverse Tenda MW6 for fun</div><div class="mt:16 f:fade-60"><time>27 févr. 2025</time></div></header><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1){font:40;_font:extrabold}
_:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
_:where(h1,h2,h3,h4,h5,h6){mt:2em}
_:where(h2){mb:1em;_font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1.5em}
_:where(video,img){max-width:full}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:3em}"><blockquote><p>Cet article n&rsquo;est pas terminé, il ne s&rsquo;agit que du début, la suite arrivera plus tard</p></blockquote><p>Ca fait un moment que je souhaitais m&rsquo;initier sérieusement au reverse d&rsquo;un appareil chinois, l&rsquo;objectif est de comprendre ses fonctionnements, vérifier ce qui est remonté aux serveur et aller le plus loin possible pour ce qu&rsquo;on peux faire avec.</p><h2 id=la-cible>La cible</h2><p>La cible sera une borne Wifi Tenda MW6, le lien officiel du fabricant est disponible ici: <a href=https://web.archive.org/web/20220707094929/https://www.tendacn.com/fr/product/specification/mw6.html>https://web.archive.org/web/20220707094929/https://www.tendacn.com/fr/product/specification/mw6.html</a></p><p>Pluseurs versions de cette borne Wifi existe:</p><ul><li>La première version de 2018 avec ses spec ici: <a href=https://web.archive.org/web/20250301134914/https://techinfodepot.shoutwiki.com/wiki/Tenda_Mesh3_%28Nova_MW6%29>https://web.archive.org/web/20250301134914/https://techinfodepot.shoutwiki.com/wiki/Tenda_Mesh3_(Nova_MW6)</a></li><li>Il semble y avoir eu de nouvelles versions jusqu&rsquo;en 2023 d&rsquo;après le site de la FCC</li></ul><p>Pour voir les versions sur le site de la FCC: <a href=https://apps.fcc.gov/oetcf/eas/reports/GenericSearch.cfm>https://apps.fcc.gov/oetcf/eas/reports/GenericSearch.cfm</a>
Grantee Code: V7T<br>Product Code: MESH3 (MESH3V3 dans mon cas)</p><p>On voit sur les différentes versions qu&rsquo;il y a eu des évolutions, les premières versions sont plus travaillées, les parties qui gèrent le wifi sont protégées par des shield qui ont disparu avec les nouvelles versions. Le modèle exact du processeur a également été modifié en passant du Realtek 8197F au Realtek 8197H.</p><p>Ce genre d&rsquo;appareil est générique: le même appareil est souvent vendu sous plusieurs marque/modèles différent mais la partie électronique est la même.</p><h2 id=le-matériel>Le matériel</h2><p>Ce répéteur wifi est basé sur une carte Realtek basée sur le rtl8197, il s&rsquo;agit d&rsquo;une carte de base que Realtek revend pour les constructeurs d&rsquo;appareil, souvent il n&rsquo;y a aucune modification ou très peu.
Voici une photo de l&rsquo;electronique de l&rsquo;appareil:
<img src=../../posts/reversetendamw6/images/PXL_20250301_192357245.jpg alt></p><p>Plusieurs zones peuvent être identifiées:</p><ul><li>Une première est la carte fille qui contient 2 ports RJ45, un bouton ainsi que le connecteur d&rsquo;alimentation. Sur la carte mère en dessous est situé le circuit qui gère l&rsquo;alimentation de la carte.</li><li>Nous avons ensuite 2 zones qui sont entourées d&rsquo;étain non utilisé, il s&rsquo;agit d&rsquo;emplacements pour mettre des shield pour protéger des interferences, ici Tenda à fait le choix de ne pas en mêttre, sur les anciennes version des shields étais présents. En évitant les interferences, le débit wifi est amélioré car il n&rsquo;y a pas de perturbation du signal, le fait qu&rsquo;il n&rsquo;y ai pas de shield empeche probablement d&rsquo;atteindre la performance maximale du wifi de l&rsquo;appareil.<ul><li>La zone la plus haute sur ma photo est celle à laquelle sont reliées les antennes wifi, le chipset qui controle le wifi est un rtl8812FR</li><li>La seconde zone avec le gros carré noir est celle qui contient le chipset Realtek rtl8197F, sur la carte, il y a également 2 emplacements d&rsquo;antennes non soudés qui sont disponibles pour utilisé le wifi avec ce chipset.</li></ul></li><li>A gauche de la zone qui contient le chipset principal se trouve un petit chipset rtl8363NB, il gère les ports rj45 de l&rsquo;appareil</li><li>Entre les 2 zones qui devraient avoir un shield se trouve 2 éléments qui vont être très importants:<ul><li>La puce mémoire qui contient le programme du logiciel, souvent il s&rsquo;agit d&rsquo;un code de base plus ou moins modifié par le constructeur</li><li>Un port UART (les 4 trous sous la puce mémoire) qui permet une connexion série avec un ordinateur, ici il est disponible prêt à être utilisé et le circuit imprimée indique ce qui correspond à chaque pastille. Sur des appareils de marques réputées, ce type de port est caché et vérouillé, sur les appareils chinois, il sont souvent laissé en place (c&rsquo;est de moins en moins le cas) ce qui permet de modifier les firmwares plus simplement.</li></ul></li></ul><p>Concernant la partie wifi, les bornes vendues en pack ont des numéros de série consécutifs et chaque pack utilise le même SSID et mot de passe. A noter que le nom du wifi pour les appareils est &ldquo;NOVA_&lt;4 derniers chiffres de l&rsquo;adresse mac>&rdquo;.
Celui du Wifi Mesh (lien des bornes entre elles en wifi) est NOVA_VIP et le mot de passe&mldr; 12345678</p><h2 id=la-récupération-dinformation-depuis-lextérieur>La récupération d&rsquo;information depuis l&rsquo;extérieur</h2><p>Pour commencer les recherches sur l&rsquo;accès, on commence par se renseigner un peu sur internet, <a href=https://github.com/latonita/tenda-reverse>ce depot github</a> regroupe un bon début de piste.</p><p>Nous pouvons également lancer un nmap sur les différentes interfaces de l&rsquo;appareil:</p><ul><li>Je commence par le port rj45 &ldquo;LAN&rdquo;:
<img src=../../posts/reversetendamw6/images/pcip.png alt="alt text">
<img src=../../posts/reversetendamw6/images/gateway.png alt="alt text"></li></ul><p>L&rsquo;ip par défaut de l&rsquo;appareil est 192.168.5.1, à partir de cette information nous pouvons apprenons qu&rsquo;il y a un dhcp sur l&rsquo;appareil et que par défaut l&rsquo;ip LAN (wifi ou port rj45 LAN) est 192.168.5.1.<br>Pour aller plus loin, voici un nmap des ports ouverts sur la prise rj45 LAN:
<img src=../../posts/reversetendamw6/images/lanport.png alt="alt text"></p><p>Il y a 2 ports ouverts: Le port 5500 et le port 9000, actuellemetn je ne sais pas à quoi servent ces ports, peux être pour la communication avec l&rsquo;application.</p><ul><li>On regarde ensuite le wifi, il devrais y avoir la même chose que pour le port rj45 LAN:
<img src=../../posts/reversetendamw6/images/lanport.png alt="alt text"></li></ul><p>A ma grande surprise: les même ports sont ouverts.</p><ul><li>Il reste le port rj45 &ldquo;WAN&rdquo; qui devrait être relié à une box pour l&rsquo;accès internet. Ici ca ne sera pas le cas, la connexion sera mon ordinateur:<br><img src=image.png alt="alt text"></li></ul><p>Cette fois c&rsquo;est plus critique, nous sommes sur l&rsquo;interface qui a accès au monde extérieur et les ports sont étranges:</p><ul><li>Le port 113 correspond à un vieux protocole de connexion: il est normal qu&rsquo;il soit fermé, tout va bien</li><li>Le port 53 est le port du protocole DNS, ce n&rsquo;est pas le mieux à placer sur un port WAN, il serait plus logique qu&rsquo;il soit sur le réseau interne (port LAN et wifi)</li><li>Les ports 80 et 443&mldr; ce sont les ports qui sevrent pour la connexion via navigateur (http et https), le fait que le port wan ouvre ces ports est plus critique: sur le port LAN nous pourrions accéder à la configuration de l&rsquo;appareil DANS le sous réseau 192.168.5.1, le nombre d&rsquo;appareil y serait limité, ici il s&rsquo;agit du réseau externe, par exemple sur l&rsquo;appareil serait directement sur la connexion internet, TOUS LE MONDE pourrais accéder à l&rsquo;interface de gestion de l&rsquo;appareil ce qui n&rsquo;est <strong>pas du tout</strong> sécurisé mais je ne suis pas surpris de trouver cette faille.
Après vérification avec netcat, aucun serveur http n&rsquo;est configuré sur ces ports, peux être qu&rsquo;il s&rsquo;agit des ports qui servent pour la configuration depuis l&rsquo;application mobile et auraient besoin de paquets spécifique?</li></ul><h2 id=lentrée-dans-la-borne-wifi>L&rsquo;entrée dans la borne wifi</h2><p>Maintenant l&rsquo;objectif va être d&rsquo;accéder au contenu de la mémoire du retour.<br>On commence par le port UART, pour cette manipulation je vais utiliser un flipper zero mais un arduino peux également suffir, sinon il faut un adaptateur TTL-USB disponible pour quelques euros sur Amazon. Sur Windows le terminal YAT fait l&rsquo;affaire, pour Linux picocom est très bien.</p><p>Les informations viennent <a href=https://github.com/latonita/tenda-reverse>du même depot github qu&rsquo;indiqué plus haut</a>, je n&rsquo;ai pas la même version de la carte mais il s&rsquo;agit du même appareil donc la plupart des informations sont exactes.</p><p>Pour effectuer la connexion sur le port UART, je vais utiliser picocom sur linux à un débit de 115200 et au démarrage de l&rsquo;appareil, pour une utilisation sur Windows, il faut que le caractère de fin de ligne soit \n (LF) pour l&rsquo;envoi de message, pour la reception il semble s&rsquo;agit de CR LF. Il faut également un outil qui supporte la couleur des messages pour éviter une sortie polluée par des caractères spéciaux.</p><h3 id=le-début-du-boot>Le début du boot</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Booting...
</span></span><span style=display:flex><span>init_ram
</span></span><span style=display:flex><span>DDR init OK
</span></span><span style=display:flex><span>init ddr ok
</span></span><span style=display:flex><span>DRAM Type: DDR2
</span></span><span style=display:flex><span>	DRAM frequency: 533MHz
</span></span><span style=display:flex><span>	DRAM Size: 128MB
</span></span><span style=display:flex><span>JEDEC id 684017, EXT id 0x6840
</span></span><span style=display:flex><span>found BH25Q64
</span></span><span style=display:flex><span>flash vendor: HuaHong
</span></span><span style=display:flex><span>BH25Q64, size<span style=color:#f92672>=</span>8MB, erasesize<span style=color:#f92672>=</span>4KB, max_speed_hz<span style=color:#f92672>=</span>55MHz
</span></span><span style=display:flex><span>auto_mode<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> addr_width<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span> erase_opcode<span style=color:#f92672>=</span>0x00000020
</span></span><span style=display:flex><span>Write PLL1<span style=color:#f92672>=</span>80c00042
</span></span><span style=display:flex><span><span style=color:#f92672>=</span>&gt;CPU Wake-up interrupt happen! GISR<span style=color:#f92672>=</span><span style=color:#ae81ff>89000080</span> 
</span></span><span style=display:flex><span>RTL8197F-VG boot release version:708 <span style=color:#f92672>(</span>Dec <span style=color:#ae81ff>28</span> 2020-22:24:53<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>999MHz<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Avant le message Booting, il semble y avoir des caractères spéciaux envoyés sur le port série, je ne sais pas à quoi ils servent et je ne pense pas en avoir besoin pour le moment.<br>Nous apprenons et confirmons beaucoup d&rsquo;informations avec ces quelques lignes:</p><ul><li>La ram est de 128MB en DDR2 à une fréquence de 533MHz</li><li>La puce mémoire est une HuaHong BH25Q64 de 8MB et organisée en blocks de 4KB, c&rsquo;est vraiment peu mais suffisant pour le code d&rsquo;une borne wifi. La marque de la puce est une marque générique chinoise, surement pour faire des économie.</li><li>La référence exacte du SOC realtek est RTL8197-VG, il s&rsquo;agit d&rsquo;un SOC MIPS qui a été mis à jour en 2020</li></ul><p>A la suite un message s&rsquo;affiche:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wait <span style=color:#66d9ef>for</span> upgrage
</span></span></code></pre></div><p>Il y a une faute qui n&rsquo;a jamais été corrigée par Realtek: upgrage au lieu de upgrade, cette faute montre l&rsquo;interet porté pour ce genre de Board: une carte pas cher qui permet de faire des appareils à bon prix mais qui ne sont pas correctement suivi (pas de mise à jour), c&rsquo;est le problème de la plupart des appareils de marques chinoises, peu cher mais bourré de failles et de problème, ce type d&rsquo;appareil reçoit 1 ou 2 petites mises à jour dans sa durée de vie, seulement pour corriger un problème vraiment critique si il y en a un.</p><h3 id=le-démarrage-du-système>Le démarrage du système</h3><p>Au démarrage du système, la borne est toujours aussi bavarde&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>start address: 0x8049f6a0
</span></span><span style=display:flex><span>Linux version 3.10.90 <span style=color:#f92672>(</span>root@localhost.localdomain<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>gcc version 4.4.7 <span style=color:#f92672>(</span>Realtek MSDK-4.4.7 Build 2001<span style=color:#f92672>)</span> <span style=color:#f92672>)</span> <span style=color:#75715e>#1 Mon Dec 27 13:04:04 CST 2021</span>
</span></span></code></pre></div><p>Le firmware a été compilé sur le SDK Realtek 4.4.7 avec un kernel linux 3.10 (en 2020 ce kernel était totalement dépassé), une grosse faille de ssécurité est présente et confirme le danger potentiel de ces produits: ils ne sont pas mis à jour et contienne de base d&rsquo;anciennes versions complètements dépassées des logiciels.</p><p>Le paramétrage du port UART:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Kernel command line: console<span style=color:#f92672>=</span>ttyS0,115200 root<span style=color:#f92672>=</span>/dev/mtdblock4
</span></span></code></pre></div><p>Cette ligne indique qu&rsquo;il est possible de se connecter en Série sur l&rsquo;appareil, nous serons redirigé sur la partition /dev/mtdblock4 lors de la connexion en tant que root.</p><p>Une ligne <strong>Très</strong> importante:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>m25p80 spi0.0: found BH25Q64, expected m25p80
</span></span></code></pre></div><p>Cette ligne indique que le firmware s&rsquo;attend à utiliser une puce m25p80 (mémoire flash NOR de 8MB de chez STMicroelectronics) or nous avons une BOHONG BG25Q64, il s&rsquo;agit surement d&rsquo;une copie de la même puce mais l&rsquo;organisation des pins ainsi que le fonctionnement de la mémoire est peux être différent.</p><p>Ensuite, une liste très importante s&rsquo;affiche:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Creating <span style=color:#ae81ff>7</span> MTD partitions on <span style=color:#e6db74>&#34;m25p80&#34;</span>:
</span></span><span style=display:flex><span>0x000000000000-0x000000800000 : <span style=color:#e6db74>&#34;ALL&#34;</span>
</span></span><span style=display:flex><span>0x000000000000-0x000000020000 : <span style=color:#e6db74>&#34;Bootloader&#34;</span>
</span></span><span style=display:flex><span>0x000000020000-0x000000030000 : <span style=color:#e6db74>&#34;CFG&#34;</span>
</span></span><span style=display:flex><span>0x000000030000-0x0000007e0000 : <span style=color:#e6db74>&#34;KernelFS&#34;</span>
</span></span><span style=display:flex><span>0x000000244012-0x0000007e0000 : <span style=color:#e6db74>&#34;RootFS&#34;</span>
</span></span><span style=display:flex><span>0x0000007e0000-0x0000007f0000 : <span style=color:#e6db74>&#34;CFM&#34;</span>
</span></span><span style=display:flex><span>0x0000007f0000-0x000000800000 : <span style=color:#e6db74>&#34;CFM_BACKUP&#34;</span>
</span></span></code></pre></div><p>Il s&rsquo;agit de <strong>toutes</strong> les zones mémoires qui composent le firmware, il devrait être possible de faire un dump du firmware&mldr; en passant par le port série, nous y reviendrons.</p><p>Pour la suite, il s&rsquo;agit de l&rsquo;extraction du firmware dans la ram: le contenu de la mémoire NOR est lu et décompressé dans la RAM, ce qui fait que les changements apportés ne sont pas persistants. Pour les rendre persistant, il faut passer par la commande CFM qui correspond à la partition CFM qui est la seule montée en écriture.</p><p>La prochaine ligne indique un changement de mot de passe pour le compte root, ca ne sera pas celui mis par défaut:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>prod_change_root_passwd<span style=color:#f92672>(</span>90<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Un process wserver se lance, il semble s&rsquo;agit d&rsquo;un serveur tcp:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>argv<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> wserver
</span></span><span style=display:flex><span>wserver
</span></span></code></pre></div><p>Il semble y avoir iptable d&rsquo;installé:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>iptables v1.4.4: Couldn<span style=color:#e6db74>&#39;t find target `access_ctrl&#39;</span>
</span></span><span style=display:flex><span>Try8<span style=color:#e6db74>`</span>iptables -h<span style=color:#e6db74>&#39; or &#39;</span>iptables --help<span style=color:#960050;background-color:#1e0010>&#39;</span> <span style=color:#66d9ef>for</span> more information.
</span></span></code></pre></div><p>Le démarrage du serveur DNS:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>arainc<span style=color:#f92672>][</span>ip 192.168.5.1<span style=color:#f92672>][</span>dns www.tendawifi.com<span style=color:#f92672>]</span>lan_start<span style=color:#f92672>(</span>169<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>arainc<span style=color:#f92672>][</span>out is <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Domain&#34;</span>:<span style=color:#e6db74>&#34;www.tendawifi.com&#34;</span>,<span style=color:#e6db74>&#34;Ix&#34;</span>:<span style=color:#e6db74>&#34;192.168.5.1&#34;</span><span style=color:#f92672>}]</span>lan_start<span style=color:#f92672>(</span>174<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>arainc<span style=color:#f92672>][</span>ip 192.168.5.1<span style=color:#f92672>][</span>dns tendawifi.com<span style=color:#f92672>]</span>lan_start<span style=color:#f92672>(</span>169<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>arainc<span style=color:#f92672>][</span>out is <span style=color:#f92672>{</span><span style=color:#e6db74>&#34;Domain&#34;</span>:<span style=color:#e6db74>&#34;tendawifi.com&#34;</span>,<span style=color:#e6db74>&#34;Ip&#34;</span>:<span style=color:#e6db74>&#34;192.168.5.1&#34;</span><span style=color:#f92672>}]</span>lan_start<span style=color:#f92672>(</span>174<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Le démarrage du wifi mesh:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>mesh_passphrase_update, before encrypt
</span></span><span style=display:flex><span><span style=color:#ae81ff>77078</span> <span style=color:#ae81ff>77</span> <span style=color:#ae81ff>38</span> <span style=color:#ae81ff>37</span> <span style=color:#ae81ff>37</span> <span style=color:#ae81ff>76</span> <span style=color:#ae81ff>38</span> 6b <span style=color:#ae81ff>70</span> <span style=color:#ae81ff>36</span> <span style=color:#ae81ff>36</span> <span style=color:#ae81ff>67</span> XX XX XX 
</span></span><span style=display:flex><span>mesh_passphrase_update, after encrypt
</span></span><span style=display:flex><span>0b 7d <span style=color:#ae81ff>49</span> 5d <span style=color:#ae81ff>13</span> 66ed <span style=color:#ae81ff>49</span> e10d90ba 2f <span style=color:#ae81ff>78</span> XX XX XX 
</span></span></code></pre></div><p>La passphrase doit être inscrite en dur quelque part dans le firmware et chiffrée puis modifiée au démarrage de la borne, le fait d&rsquo;envoyer cette information sur le port série casse tous l&rsquo;interet du chiffrement&mldr;</p><p>Encore une chose amusante: la version du firmware n&rsquo;a pas été incrémentée par les développeurs et se retrouve dans le fimware de prod:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Warning: The source codes has been modified but the version number has not been incremented.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>There are two ways to increment the version number:
</span></span><span style=display:flex><span>If there are few changes, you can run <span style=color:#e6db74>`</span>make cbb/wifi/tendawifi/steerd_only<span style=color:#e6db74>`</span> to build, and the patch version will be automatically incremented.
</span></span><span style=display:flex><span>Or you can run <span style=color:#e6db74>`</span>make -C cbb/wifi/tendawifi/steerd set_version version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt; [COMMENT]&#34;</span><span style=color:#e6db74>`</span> to specify the new version.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>After you increment the version number, the file <span style=color:#e6db74>`</span>cbb/wifi/tendawifi/steerd/version.txt<span style=color:#e6db74>`</span> will be updated, you can submit the changes to the server when needed. E.g:
</span></span><span style=display:flex><span>    git add cbb/wifi/tendawifi/steerd cbb/wifi/tendawifi/kernel/td_multiap_steer
</span></span><span style=display:flex><span>    git commit -m <span style=color:#e6db74>&#34;update version for steerd.&#34;</span>
</span></span><span style=display:flex><span>    git push origin HEAD:refs/for/dev_ugw6.0_main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>If you are using local compiled <span style=color:#e6db74>`</span>steerd<span style=color:#e6db74>`</span>, this warning may appear again <span style=color:#66d9ef>until</span> you recompile it.
</span></span><span style=display:flex><span>To rebuild the release package <span style=color:#66d9ef>for</span> RTL, you can run:
</span></span><span style=display:flex><span>    make cbb/wifi/tendawifi/steerd_only
</span></span><span style=display:flex><span>    make release
</span></span><span style=display:flex><span>To rebuild the release package <span style=color:#66d9ef>for</span> QCA, you can run:
</span></span><span style=display:flex><span>    make cbb/wifi/tendawifi/steerd_only
</span></span><span style=display:flex><span>    tar -C cbb/wifi -c -j -f cbb/wifi/&lt;VENDOR&gt;_wifi_release.bz2 &lt;VENDOR&gt;_wifi_release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3.0.61 <span style=color:#f92672>(</span>Auto increment from http://172.16.30.83:18088/svn/11S_MESH/SourceCodes/Trunk/MW6V3.0/develop/cbb/wifi/tendawifi/steerd  53<span style=color:#f92672>)</span>
</span></span></code></pre></div><h3 id=après-le-démarrage>Après le démarrage</h3><p>Après le démarrage un message est renvoyé régulièrement sur le port série, il contient&mldr; le ssid des réseaux wifi ainsi que leurs mots de passe&mldr; en clair:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>wlan_get_master_cfg<span style=color:#f92672>(</span>151<span style=color:#f92672>)</span> SSID<span style=color:#f92672>[</span>NOVA_XXXX<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>wlan_get_master_cfg<span style=color:#f92672>(</span>160<span style=color:#f92672>)</span> wifi_pwd<span style=color:#f92672>[</span>XXXXXX<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>wlan_get_master_cfg<span style=color:#f92672>(</span>151<span style=color:#f92672>)</span> SSID<span style=color:#f92672>[</span>NOVA_VIP<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>wlan_get_master_cfg<span style=color:#f92672>(</span>160<span style=color:#f92672>)</span> wifi_pwd<span style=color:#f92672>[</span>12345678<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>Une fois de plus, il n&rsquo;y a aucune sécurité.</p><p>D&rsquo;autres messages reviennents en boucle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ERROR:ugw_proc_send_msg<span style=color:#f92672>[</span>313<span style=color:#f92672>]</span>connect server is fail.
</span></span><span style=display:flex><span>func:log_encode_msg_to_server, line:64, send msg is fail.
</span></span></code></pre></div><p>L&rsquo;erreur viens peux être du fait que la borne n&rsquo;est pas connectée au web et ne peux pas contacter sa &ldquo;maison&rdquo; (i.e. un serveur chinois)</p><p>La borne connait également les bornes associées à son pack et cherche à les contacter (ma borne correspond au sn X-1):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ptr-&gt;serial_num<span style=color:#f92672>=</span>E8593010207L00AAAX is offline
</span></span><span style=display:flex><span>ptr-&gt;serial_num<span style=color:#f92672>=</span>E8593010207L00AAAY is offline
</span></span></code></pre></div><p>Lorsqu&rsquo;un message est envoyé via le port série depuis un appareil externe, ce message s&rsquo;affiche:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Normal startupGive root password <span style=color:#66d9ef>for</span> system maintenance
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>or type Control-D <span style=color:#66d9ef>for</span> normal startup<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>Normal startup
</span></span></code></pre></div><p>Pour résumer: depuis la console série, si on envoie un caractère de retour à la ligne puis le mot de passe suivi d&rsquo;un caractère de retour à la ligne nous pouvons accéder à la console série en tant que root et modifier des paramètres du logiciel.</p><p>Dernière chose pour cette (longue) partie: le démarrage de telnet. lors de l&rsquo;appui sur le bouton &ldquo;reset&rdquo; de l&rsquo;appareil, ces lignes apparaissent sur le port série:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>[</span>rest_button_pressed_handle<span style=color:#f92672>][</span>180<span style=color:#f92672>][</span>luminais<span style=color:#f92672>]</span> gpio_ctrl : reset button pressed : <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>rest_button_pressed_handle<span style=color:#f92672>][</span>180<span style=color:#f92672>][</span>luminais<span style=color:#f92672>]</span> gpio_ctrl : reset button pressed : <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>rest_button_pressed_handle<span style=color:#f92672>][</span>180<span style=color:#f92672>][</span>luminais<span style=color:#f92672>]</span> gpio_ctrl : reset button pressed : <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>et au bout de 3s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tim <span style=color:#f92672>[</span>netctrl_recv_hanle<span style=color:#f92672>][</span>1052<span style=color:#f92672>]</span> i recv msg 72?op<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>tim <span style=color:#f92672>[</span>netctrl_recv_hanle<span style=color:#f92672>][</span>1055<span style=color:#f92672>]</span> i recv id <span style=color:#ae81ff>72</span>
</span></span><span style=display:flex><span>tim <span style=color:#f92672>[</span>netctrl_recv_hanle<span style=color:#f92672>][</span>1060<span style=color:#f92672>]</span> role get SUCESS
</span></span><span style=display:flex><span>tim <span style=color:#f92672>[</span>netctrl_recv_hanle<span style=color:#f92672>][</span>1068<span style=color:#f92672>]</span> handle id <span style=color:#ae81ff>72</span> ,role <span style=color:#ae81ff>3</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>djc__telnet_cmd is telnetd -b 192.168.5.1____telnet_start<span style=color:#f92672>(</span>46<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>argv<span style=color:#f92672>[</span>0<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> telnetd
</span></span><span style=display:flex><span>argv<span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> -b
</span></span><span style=display:flex><span>argv<span style=color:#f92672>[</span>2<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> 192.168.5.1
</span></span><span style=display:flex><span>telnetd
</span></span></code></pre></div><p>telnet est démarré!</p><p>Le mot de passe est le même que celui à utilisé pour la connexion root sur le port série.</p><p>Comme indiqué avant, l&rsquo;obtention du mot de passe est indiqué <a href=https://github.com/latonita/tenda-reverse>sur ce dépot github</a>. Pour obtenir le mot de passe, il faut calculer la base64 de la clé de sécurité du wifi:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>base64<span style=color:#f92672>(</span>&lt;mdp ssid NOVA_XXXX&gt;<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Ce qui donne en commande linux:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>echo -n <span style=color:#e6db74>&#34;&lt;mdp wifi&gt;&#34;</span> | base64
</span></span></code></pre></div><h3 id=le-démarrage-sur-le-bootloader-de-la-borne-wifi>Le démarrage sur le bootloader de la borne wifi</h3><p>Ici il s&rsquo;agit d&rsquo;un bootloader Realtek, sur d&rsquo;autres processeur il s&rsquo;agit généralement de U-Boot. La manière de démarrer sur le bootloader varie suivant les appareils, sur certains il faut envoyer le caractère d&rsquo;une touche de clavier sur le port série au démarrage (touche echap ou entrée), pour le Tenda MW6 il faut <strong>brancher l&rsquo;appareil puis rapidement appuyer et maintenir le bouton reset enfoncé au démarrage de la borne</strong>.</p><p>Lors du démarrage, la console série va bloquer sur le message:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>=</span>&gt;CPU Wake-up interrupt happen! GISR<span style=color:#f92672>=</span><span style=color:#ae81ff>89000080</span> 
</span></span><span style=display:flex><span>RTL8197F-VG boot release version:708 <span style=color:#f92672>(</span>Dec <span style=color:#ae81ff>28</span> 2020-22:24:53<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>999MHz<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Au bout de quelques secondes, la borne démarre en mode bootloader et affiche le message:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Entry disaster mode
</span></span></code></pre></div><p>Ensuite nous avons la main sur le shell du bootloader:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>&lt;RealTek&gt;
</span></span></code></pre></div><p>Voici la liste des commandes du bootloader:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>&lt;RealTek&gt;?
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>----------------- COMMAND MODE HELP ------------------
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HELP <span style=color:#f92672>(</span>?<span style=color:#f92672>)</span>				    : Print this help message
</span></span><span style=display:flex><span>DB &lt;Address&gt; &lt;Len&gt;
</span></span><span style=display:flex><span>DW &lt;Address&gt; &lt;Len&gt;
</span></span><span style=display:flex><span>EB &lt;Address&gt; &lt;Value1&gt; &lt;Value2&gt;...
</span></span><span style=display:flex><span>EW &lt;Address&gt; &lt;Value1&gt; &lt;Value2&gt;...
</span></span><span style=display:flex><span>CMP: CMP &lt;dst&gt;&lt;src&gt;&lt;length&gt;
</span></span><span style=display:flex><span>IPCONFIG:&lt;TargetAddress&gt;
</span></span><span style=display:flex><span>MEMCPY:&lt;dst&gt;&lt;src&gt;&lt;length&gt;
</span></span><span style=display:flex><span>AUTOBURN: 0/1
</span></span><span style=display:flex><span>LOADADDR: &lt;Load Address&gt;
</span></span><span style=display:flex><span>J: Jump to &lt;TargetAddress&gt;
</span></span><span style=display:flex><span>reboot
</span></span><span style=display:flex><span>FLI: Flash init
</span></span><span style=display:flex><span>FLR: FLR &lt;dst&gt;&lt;src&gt;&lt;length&gt;
</span></span><span style=display:flex><span>FLW &lt;dst_ROM_offset&gt;&lt;src_RAM_addr&gt;&lt;length_Byte&gt; &lt;SPI cnt#&gt;: Write to SPI
</span></span><span style=display:flex><span>MDIOR:  MDIOR  &lt;reg&gt;
</span></span><span style=display:flex><span>MDIOW:  MDIOW &lt;PHYID&gt; &lt;reg&gt; &lt;data&gt;
</span></span><span style=display:flex><span>PHYR: PHYR &lt;PHYID&gt;&lt;reg&gt;
</span></span><span style=display:flex><span>PHYW: PHYW &lt;PHYID&gt;&lt;reg&gt;&lt;data&gt;
</span></span><span style=display:flex><span>PHYPR: PHYPR &lt;PHYID&gt;&lt;page&gt;&lt;reg&gt;
</span></span><span style=display:flex><span>PHYPW: PHYPW &lt;PHYID&gt;&lt;page&gt;&lt;reg&gt;&lt;data&gt;
</span></span><span style=display:flex><span>COUNTER: Dump Asic Counter
</span></span><span style=display:flex><span>XMOD &lt;addr&gt;  <span style=color:#f92672>[</span>jump<span style=color:#f92672>]</span> 
</span></span><span style=display:flex><span>TI : timer init 
</span></span><span style=display:flex><span>T : T &lt;len&gt; &lt;loop&gt;
</span></span><span style=display:flex><span>ETH : startup Ethernet
</span></span><span style=display:flex><span>CPUClk: 
</span></span><span style=display:flex><span>CP0
</span></span><span style=display:flex><span>ERASECHIP
</span></span><span style=display:flex><span>ERASESECTOR
</span></span><span style=display:flex><span>SPICLB <span style=color:#f92672>(</span>&lt;flash ID&gt;<span style=color:#f92672>)</span> : SPI Flash Calibration
</span></span><span style=display:flex><span>SFLTEST : SFLTEST &lt;offset&gt; &lt;length&gt; &lt;count&gt;   - spi nor flash test
</span></span><span style=display:flex><span>D8 &lt;Address&gt;
</span></span><span style=display:flex><span>E8 &lt;Address&gt; &lt;Value&gt;
</span></span></code></pre></div><p>A partir de maintenant, l&rsquo;appareil est sous controle, il est possible de:</p><ul><li>Démarrer sur le bootloader et extraire le firmware et le contenu de la mémoire</li><li>Avoir un accès root et modifier les paramètres</li><li>Flasher un autre firmware sans avoir à déssouder la puce mémoire, malheureusement openWRT n&rsquo;est pas compatible avec cet appareil à cause du driver Realtek qui n&rsquo;est pas disponible en opensource, je ne pense pas aller jusqu&rsquo;à créer une image openWRT pour cet appareil.</li></ul><p>La prochaine étape va être le dump du firmware sans déssouder la puce.</p><h2 id=dump-du-firmware>Dump du firmware</h2><p>Nous voici à la partie intéressante: faire une sauvegarde complète de la mémoire flash de l&rsquo;appareil SANS déssouder la puce.</p><h3 id=le-principe-du-dump-depuis-le-bootloader>Le principe du dump depuis le bootloader</h3><p>Pour récupérer les informations de la mémoire, nous aurons besoin de l&rsquo;appareil démarré en mode bootloader et connecté via le port UART à notre ordinateur avec picocom. A partir de cette étape 2 commandes seront utiles:</p><ul><li>FLR qui permet de charger une zone mémoire de la flash dans la ram</li><li>DW qui permet d&rsquo;envoyer via le port UART les informations de la ram</li></ul><p>Utilisation de DW: <code>dw &lt;adresse de la mémoire à lire> &lt;nombre d'élément à lire></code></p><p>Voici un exemple de ce qui s&rsquo;affiche sur le terminal:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>&lt;RealTek&gt;DW <span style=color:#ae81ff>80000000</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>80000000: <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00000000</span> <span style=color:#ae81ff>00000000</span>
</span></span><span style=display:flex><span>&lt;RealTek&gt;
</span></span></code></pre></div><ul><li>Nous pouvons afficher les éléments sur plusieurs lignes (il faut obligatoirement indiquer un multiple de 4)</li><li>Les octets sont par bloc de 4</li><li>La première valeur est l&rsquo;adresse, nous pouvons la retirer</li><li>Les éléments sont splitté avec une tabulation</li></ul><p>Utilisation de FLR: <code>flr &lt;adresse de la ram où sera stockée la mémoire> &lt;adrese de la flash à lire> &lt;nombre d'éléments à lire (multiple de 4)></code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>&lt;RealTek&gt;FLR <span style=color:#ae81ff>80000000</span> <span style=color:#ae81ff>4000</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>Flash read from <span style=color:#ae81ff>40000</span> to <span style=color:#ae81ff>80000000</span> with <span style=color:#ae81ff>00000004</span> bytes         ?
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>Y<span style=color:#f92672>)</span>es , <span style=color:#f92672>(</span>N<span style=color:#f92672>)</span>o ? --&gt; y
</span></span><span style=display:flex><span>Flash Read Successed!
</span></span><span style=display:flex><span>&lt;RealTek&gt;
</span></span></code></pre></div><ul><li>On charge les éléments dans la RAM, la commande nous demande de confirmer l&rsquo;action.</li></ul><p>Algorithme général:</p><pre tabindex=0><code>Pour i de 0x0 à 0x000000800000 faire:
    Envoyer la commande: FLR 80000000 i 4
    Envoyer la commande: y
    Envoyer la commande: DW 80000000 4

    Ajouter au fichier de dump les valeurs de la chaine reçue suite à la commande DW en faisant un split \t et en retirant le premier élément, chaque élément du tableau correspond aux valeurs des octets donc la string doit être convertie en hex (ex: str(0A) doit donner 0x0A)
Fin pour
</code></pre><h3 id=le-dump>Le dump</h3><p>Pour le script, je réutilise le script dump_flash.py présent sur ce lien: <a href=https://github.com/banksy-git/lidl-gateway-freedom/tree/master/scripts>https://github.com/banksy-git/lidl-gateway-freedom/tree/master/scripts</a></p><p>Comme je l&rsquo;ai modfiié, voici ma version:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># Dump out flash from RTL bootloader... very slowly!</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#====================================================</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Author: Paul Banks [https://paulbanks.org/]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> serial
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> struct
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> argparse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>doit</span>(s, fOut, start_addr<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, end_addr<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get a couple of prompts for sanity</span>
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>read_until(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&lt;RealTek&gt;&#34;</span>)
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    s<span style=color:#f92672>.</span>read_until(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&lt;RealTek&gt;&#34;</span>)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Starting...&#34;</span>)
</span></span><span style=display:flex><span>    step <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x100</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span>(step<span style=color:#f92672>%</span><span style=color:#ae81ff>4</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> flash_addr <span style=color:#f92672>in</span> range(start_addr, end_addr, step):
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;FLR 80000000 </span><span style=color:#e6db74>%X</span><span style=color:#e6db74> </span><span style=color:#e6db74>%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (flash_addr, step))
</span></span><span style=display:flex><span>        print(s<span style=color:#f92672>.</span>read_until(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;--&gt; &#34;</span>))
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;y</span><span style=color:#ae81ff>\r</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        print(s<span style=color:#f92672>.</span>read_until(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&lt;RealTek&gt;&#34;</span>))
</span></span><span style=display:flex><span>        s<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;DW 80000000 </span><span style=color:#e6db74>%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (step<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span>        data <span style=color:#f92672>=</span> s<span style=color:#f92672>.</span>read_until(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;&lt;RealTek&gt;&#34;</span>)<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;utf-8&#34;</span>)<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n\r</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> l <span style=color:#f92672>in</span> data:
</span></span><span style=display:flex><span>            parts <span style=color:#f92672>=</span> l<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> p <span style=color:#f92672>in</span> parts[<span style=color:#ae81ff>1</span>:]:
</span></span><span style=display:flex><span>                fOut<span style=color:#f92672>.</span>write(struct<span style=color:#f92672>.</span>pack(<span style=color:#e6db74>&#34;&gt;I&#34;</span>, int(p, <span style=color:#ae81ff>16</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__<span style=color:#f92672>==</span><span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    parser <span style=color:#f92672>=</span> argparse<span style=color:#f92672>.</span>ArgumentParser(<span style=color:#e6db74>&#34;RTL Flash Dumper&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--serial-port&#34;</span>, type<span style=color:#f92672>=</span>str,
</span></span><span style=display:flex><span>                        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Serial port device - e.g. /dev/ttyUSB0&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--output-file&#34;</span>, type<span style=color:#f92672>=</span>str,
</span></span><span style=display:flex><span>                        help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Path to file to save dump into&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--start-addr&#34;</span>, type<span style=color:#f92672>=</span>str, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Start address&#34;</span>,
</span></span><span style=display:flex><span>                        default<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;0x0&#34;</span>)
</span></span><span style=display:flex><span>    parser<span style=color:#f92672>.</span>add_argument(<span style=color:#e6db74>&#34;--end-addr&#34;</span>, type<span style=color:#f92672>=</span>str, help<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;End address&#34;</span>,
</span></span><span style=display:flex><span>                        default<span style=color:#f92672>=</span>hex(<span style=color:#ae81ff>8</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1024</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    args <span style=color:#f92672>=</span> parser<span style=color:#f92672>.</span>parse_args()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    s <span style=color:#f92672>=</span> serial<span style=color:#f92672>.</span>Serial(args<span style=color:#f92672>.</span>serial_port, <span style=color:#ae81ff>115200</span>)
</span></span><span style=display:flex><span>    start_addr <span style=color:#f92672>=</span> int(args<span style=color:#f92672>.</span>start_addr, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    end_addr <span style=color:#f92672>=</span> int(args<span style=color:#f92672>.</span>end_addr, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(args<span style=color:#f92672>.</span>output_file,<span style=color:#e6db74>&#34;wb&#34;</span>) <span style=color:#66d9ef>as</span> fOut:
</span></span><span style=display:flex><span>        doit(s, fOut, start_addr, end_addr)
</span></span></code></pre></div><p>Maintenant on devrait avoir notre fichier dump&mldr; Ou pas!<br>J&rsquo;ai eu beucoup de difficulté à réussir mon dump, avec le flipper zero il y avais un plantage à un moment (toujours le même, avec des variations), j&rsquo;ai finalement réussi à obtenir quelque chose avec un arduino en mode adaptateur série.</p><h3 id=lanalyse-du-dump>L&rsquo;analyse du dump</h3><p>Bon maintenant on a quelque chose, on peux regarder avec binwalk ce que contient notre firmware:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ binwalk dump.bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DECIMAL       HEXADECIMAL     DESCRIPTION
</span></span><span style=display:flex><span>--------------------------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>35096</span>         0x8918          CRC32 polynomial table, big endian
</span></span><span style=display:flex><span><span style=color:#ae81ff>132130</span>        0x20422         Motorola S-Record; binary data in text format, record type: data <span style=color:#f92672>(</span>24-bit<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>6085013</span>       0x5CD995        LZMA compressed data, properties: 0x7E, dictionary size: <span style=color:#ae81ff>0</span> bytes, uncompressed size: <span style=color:#ae81ff>14336</span> bytes
</span></span><span style=display:flex><span><span style=color:#ae81ff>8260255</span>       0x7E0A9F        AU audio data, <span style=color:#ae81ff>1886596712</span> sample rate, <span style=color:#ae81ff>779118858</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8260559</span>       0x7E0BCF        AU audio data, <span style=color:#ae81ff>1883072366</span> sample rate, <span style=color:#ae81ff>1635125870</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8270060</span>       0x7E30EC        AU audio data, <span style=color:#ae81ff>1886663276</span> sample rate, <span style=color:#ae81ff>1936614446</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8270104</span>       0x7E3118        AU audio data, <span style=color:#ae81ff>779104880</span> sample rate, <span style=color:#ae81ff>1768716147</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8325791</span>       0x7F0A9F        AU audio data, <span style=color:#ae81ff>1886596712</span> sample rate, <span style=color:#ae81ff>779118858</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8326095</span>       0x7F0BCF        AU audio data, <span style=color:#ae81ff>1883072366</span> sample rate, <span style=color:#ae81ff>1635125870</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8335596</span>       0x7F30EC        AU audio data, <span style=color:#ae81ff>1886663276</span> sample rate, <span style=color:#ae81ff>1936614446</span> channels
</span></span><span style=display:flex><span><span style=color:#ae81ff>8335640</span>       0x7F3118        AU audio data, <span style=color:#ae81ff>779104880</span> sample rate, <span style=color:#ae81ff>1768716147</span> channels
</span></span></code></pre></div><p>Hum&mldr; ce n&rsquo;est pas très parlant, nous devrions avoir un fichier squashfs ou quelque chose qui nous indique qu&rsquo;il y a un bootloader ainsi que des fichiers de configuration et un OS.</p><p>On regarde le résultat du fichier binaire:</p><p><img src=../../posts/reversetendamw6/images/hexdumpbin.png alt="alt text"></p><p>L&rsquo;adresse 007E0000 est valide, nous retrouvons correctement ce qu&rsquo;il y avait d&rsquo;indiqué au démarrage (nous tombons sur la partition &ldquo;CFM&rdquo;), les autres adresses sont également valides.<br>En regardant un peu, on tombe sur des valeurs cohérentes mais dans le mauvais ordre, je pense à un simple problème d&rsquo;ordre little/big endian&mldr; En recherchant un peu sur google, on trouve une solution avec la commande xxd (l&rsquo;astuce viens de <a href=https://web.archive.org/web/20190220222218/https://llllloooooo.blogspot.com/2017/12/convert-binary-data-files-between-big.html>ce lien</a>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>xxd -e -g4 dump.bin | xxd -r &gt; dumpv2.bin
</span></span></code></pre></div><p>On regarde de nouveau le fichier avec binwalk:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ binwalk truedump.bin
</span></span><span style=display:flex><span>DECIMAL       HEXADECIMAL     DESCRIPTION
</span></span><span style=display:flex><span>--------------------------------------------------------------------------------
</span></span><span style=display:flex><span><span style=color:#ae81ff>1709</span>          0x6AD           JBOOT STAG header, image id: 2, timestamp 0x146200, image size: <span style=color:#ae81ff>1744830464</span> bytes, image JBOOT checksum: 0xA200, header JBOOT checksum: 0x208F
</span></span><span style=display:flex><span><span style=color:#ae81ff>35096</span>         0x8918          CRC32 polynomial table, little endian
</span></span><span style=display:flex><span><span style=color:#ae81ff>36192</span>         0x8D60          gzip compressed data, maximum compression, from Unix, last modified: 2020-12-29 06:24:56
</span></span><span style=display:flex><span><span style=color:#ae81ff>206872</span>        0x32818         LZMA compressed data, properties: 0x5D, dictionary size: <span style=color:#ae81ff>8388608</span> bytes, uncompressed size: <span style=color:#ae81ff>7462588</span> bytes
</span></span><span style=display:flex><span><span style=color:#ae81ff>3255942</span>       0x31AE86        JBOOT STAG header, image id: 7, timestamp 0xE679B8FA, image size: <span style=color:#ae81ff>2658054926</span> bytes, image JBOOT checksum: 0x63D8, header JBOOT checksum: 0x3F48
</span></span></code></pre></div><p>On regarde le résultat avec un éditeur hexa:</p><p><img src=../../posts/reversetendamw6/images/hexdumpbin2.png alt="alt text"></p><p>C&rsquo;est&mldr; mieux?<br>Désormais le texte de la configuration est lisible, on peux voir les chaines de caractères dans le bon ordre, nous sommes sur la bonne voie mais il manque une chose&mldr; comment est compressé le système de fichier?</p><h3 id=casser-la-compression-de-la-partition-rootfs>Casser la compression de la partition RootFS</h3><p>Nous avons donc une image propre mais le système de fichier n&rsquo;est pas détecté par binwalk ce qui veux dire qu&rsquo;il utilise un système de compression propriétaire ou modifier et inconnu par binwalk. Il faut donc regarder ce qu&rsquo;on obtiens sur un éditeur hexa et comprendre.<br>On commence donc par regarder les données à la position 0x244012, il s&rsquo;agit de la position de départ du RootFS qui contient les fichiers du système d&rsquo;exploitation:</p><p>On utilise la commande:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>hexdump -s 0x244012 -n <span style=color:#ae81ff>128</span> truedump.bin -C
</span></span></code></pre></div><p>On se retrouve avec ces valeurs:</p><pre tabindex=0><code>00244012  6e 69 63 65 80 01 00 00  00 38 9d 80 00 00 02 00  |nice.....8......|
00244022  36 00 00 00 04 00 11 00  e0 00 01 00 04 00 00 00  |6...............|
00244032  5b 14 de 08 00 00 00 00  8c 99 38 00 00 00 00 00  |[.........8.....|
00244042  84 99 38 00 00 00 00 00  ff ff ff ff ff ff ff ff  |..8.............|
00244052  14 7a 38 00 00 00 00 00  5c 86 38 00 00 00 00 00  |.z8.....\.8.....|
00244062  18 96 38 00 00 00 00 00  76 99 38 00 00 00 00 00  |..8.....v.8.....|
00244072  54 65 6e 64 61 00 00 01  fd 69 95 c6 03 c0 bb 46  |Tenda....i.....F|
00244082  e0 a2 02 21 01 0a 00 00  42 e5 34 20 e0 91 5f 23  |...!....B.4 .._#|
</code></pre><p>2 choses sont intéressantes:</p><ul><li>le début est nice (en hexa:6e 69 63 65)</li><li>A un moment il y a le mot &ldquo;Tenda&rdquo;</li><li>le caractère 8 se répète, il est beaucoup d&rsquo;octets à 0 et à ff</li></ul><h4 id=la-méthode-naive>La méthode naive</h4><p>La première méthode va être de confirmer ce chiffrement en trouvant un appareil similaire dont le firmware serait disponible et voir si quelqu&rsquo;un à des infos ou a fait quelque chose.</p><h2 id=liens-qui-mont-été-utiles>Liens qui m&rsquo;ont été utiles</h2><ul><li><a href=https://github.com/latonita/tenda-reverse>https://github.com/latonita/tenda-reverse</a></li><li><a href="https://www.youtube.com/watch?v=ZmZuKA-Rst0">https://www.youtube.com/watch?v=ZmZuKA-Rst0</a></li><li><a href=https://github.com/choryuidentify/openwrt-rtl8197f/tree/master>Un portage d&rsquo;openwrt pour le chipset 8197</a></li><li><a href=https://github.com/Alexey-Tsarev/openwrt-rtl819x>Un second portage d&rsquo;openwrt</a></li><li><a href=https://sourceforge.net/projects/rtl819x/files/>Les SDK pour les soc Realtek</a></li><li><a href=https://github.com/aborgda/rtl819x_3411d_mg1200ac/tree/master>Encore un SDK</a></li><li><a href=https://github.com/AskeyDB40/RTL8197_3411D_2/tree/masters>Un autre SDK</a></li><li><a href=https://github.com/7felix7/bootcode_rtl8197f/tree/master>Le code du Bootloader du Realtek 8197</a></li><li><a href=https://github.com/7felix7/openwrt_rtk8197f>Un autre portage openWRT</a></li><li><a href=https://www.cyberark.com/resources/threat-research-blog/accessing-and-dumping-firmware-through-uart>Extraction de firmware sans soudure</a></li><li><a href="https://www.youtube.com/watch?v=8LRelmB55QE">Extraire un firmware avec un flipper zero</a></li><li><a href="https://www.youtube.com/watch?v=GIU4yJn2-2A">Analyser un firmware</a></li><li><a href=https://armx.exploitlab.net/docs/emulating-tenda-ac15.html#section-1---obtaining-the-firmware>L&rsquo;analyse d&rsquo;un appareil Tenda</a></li><li><a href=https://fr3ak-hacks.medium.com/analysing-and-extracting-firmware-using-binwalk-982012281ff6>Un guide pour Binwalk</a></li><li><a href=https://oldwiki.archive.openwrt.org/doc/techref/bootloader/realtek>Documentation sur le bootloader</a></li><li><a href=https://wiki.8devices.com/komikan:uboot>Envoi de firmware via TFTP</a></li><li><a href=https://paulbanks.org/projects/lidl-zigbee/#overview>Hack du silvercrest smart home de Lidl</a></li><li><a href="https://gist.github.com/vitali2y/79ca747be49f146971b5a7fa89a0a637?permalink_comment_id=3323240">Bootloader realtek</a></li><li><a href=https://github.com/banksy-git/lidl-gateway-freedom/tree/master/scripts>Script pour faire dump le firmware d&rsquo;un SoC rtl8196/rtl8197</a></li><li><a href=https://byebyesky.github.io/blog/hacking/embedded/2019/05/28/hacking-a-router-3.html>Reverse d&rsquo;un routeur Tenda</a></li><li><a href=https://web.archive.org/web/20190220222218/https://llllloooooo.blogspot.com/2017/12/convert-binary-data-files-between-big.html>xxd pour passer de big à little endian</a></li><li><a href="https://www.youtube.com/watch?v=I1w_HQ7soSE">Tuto vidéo sur le hack d&rsquo;un routeur</a></li><li><a href=https://github.com/bread-b4nk/reversing-tenda-n301/blob/main/README.md>Reverse routeur Tenda n301</a></li></ul></div></article><footer class=py:24><div class="f:fade-30 f:14 mb:8">copyright ©Loonaire</div><div class="f:fade-60 f:12">Theme <a class=f:bold href=https://github.com/serkodev/holy _target=_blank>Holy</a></div></footer></div></div></body></html>