<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go: Profiler une app - Loonaire Blog</title><meta name=description content="Un petit article mémo pour le profilage en Go.
Profilage de base Dans mon cas, je développe un serveur tcp donc le logiciel reste ouvert indéfiniment, cette solution sera également pour les serveurs http et les autres développement utilisant des boucles infinies.
Voici le code de base:
package main import ( &#34;fmt&#34; _ &#34;net/http/pprof&#34; ) func main() { go func() { log.Println(http.ListenAndServe(&#34;localhost:6060&#34;, nil)) }() // AJOUTER ICI LE RESTE DE VOTRE CODE fmt."><meta name=author content><link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script>
<script src=https://unpkg.com/@master/styles@1.13.0></script>
<script src=https://unpkg.com/master-styles-group></script>
<script src=https://unpkg.com/themes.js></script>
<script>window.themes=window.themes||new window.Themes</script></head><body class="bg:fade-84@dark font:fade-16@dark"><nav class="w:full h:90 fixed bg:fade-84/.95@dark bg:white z:1000"><div class="h:full
w:full
max-w:1200
mx:auto
px:32
d:flex
align-items:center"><div><a href=../../ class="mr-3 font:extralight">Loonaire Blog</a></div><div class=ml:auto><a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../posts/ title>Articles</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../other/ title>Autre contenu</a>
<a class="font:semibold
font:fade
font:fade-10:hover
font:fade-30.active
px:8
transition:150ms;ease-in" href=../../about title>A propos</a></div></div></nav><div class="d:flex flex:column@<=sm pt:90 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:700 w:full box:content-box"><article class="box:border-box pt:32"><header class=mb:32><div class="font:40 font:extrabold">Go: Profiler une app</div><div class="mt:16 f:fade-60"><time>14 oct. 2023</time></div></header><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-10;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2;6;_r:4}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1){font:40;_font:extrabold}
_:where(h1,h2,h3)+:where(h1,h2,h3){mt:.5em}
_:where(h1,h2,h3,h4,h5,h6){mt:2em}
_:where(h2){mb:1em;_font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1.125em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1.5em}
_:where(video,img){max-width:full}
_:where(a,mark){text-underline-offset:3}"><p>Un petit article mémo pour le profilage en Go.</p><h2 id=profilage-de-base>Profilage de base</h2><p>Dans mon cas, je développe un serveur tcp donc le logiciel reste ouvert indéfiniment, cette solution sera également pour les serveurs http et les autres développement utilisant des boucles infinies.</p><p>Voici le code de base:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span> <span style=color:#e6db74>&#34;net/http/pprof&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;localhost:6060&#34;</span>, <span style=color:#66d9ef>nil</span>))
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// AJOUTER ICI LE RESTE DE VOTRE CODE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Explications:<br>L&rsquo;import <code>_ "net/http/pprof"</code> force l&rsquo;import du package pprof http, ensuite il faut lancer un serveur http dans une goroutine pour pouvoir récupérer les informations de la mémoire en temps réel.<br>Pour accéder aux données en temps réel, il faut se connecter avec le lien: <code>http://localhost:6060/debug/pprof</code>, le port 6060 est celui par défaut.</p><h2 id=pour-crée-des-fichiers-de-profilage>Pour crée des fichiers de profilage</h2><p>Cette méthode demande l&rsquo;installation de graphviz.<br>Une autre méthode consiste à passer par la création d&rsquo;un fichier qui contient les informations de profilage et qui peux être lu et chargé plus tard par des outils de profilage. Cette technique demande un arrêt propre du programme ce qui peux être compliqué dans le cas de développement avec des boucles infinie.</p><p>Voici le code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;runtime/pprof&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cpuProfile</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#e6db74>&#34;cpuprofile&#34;</span>) <span style=color:#75715e>// crée un fichier qui contiendra les informations du profilage du CPU
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pprof</span>.<span style=color:#a6e22e>StartCPUProfile</span>(<span style=color:#a6e22e>cpuProfile</span>) <span style=color:#75715e>// démarre le profilage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>pprof</span>.<span style=color:#a6e22e>StopCPUProfile</span>() <span style=color:#75715e>// arrête le profilage
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// AJOUTER ICI LE RESTE DE VOTRE CODE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Pour récuperer le résultat du profilage, voici un exemple qui permet de récupérer un fichier pdf du profilage:<br><code>go tool pprof -pdf fichierbuild.exe cpuprofile > cpuprofile.pdf</code></p></div></article><footer class=py:24><div class="f:fade-30 f:14 mb:8">copyright ©Loonaire</div><div class="f:fade-60 f:12">Theme <a class=f:bold href=https://github.com/serkodev/holy _target=_blank>Holy</a></div></footer></div></div></body></html>